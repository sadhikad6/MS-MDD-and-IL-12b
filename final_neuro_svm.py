# -*- coding: utf-8 -*-
"""Final Neuro SVM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1blj8XjmpwBajjCItviBGmZU-7JbbzCxE
"""

import sys
import cv2 
import numpy as np
from google.colab.patches import cv2_imshow
from google.colab import files
from matplotlib import pyplot as plt

import zipfile
import io
zf = zipfile.ZipFile('healthy_fmri.zip')
zf.extractall()
#zf.printdir()

zf = zipfile.ZipFile('ms_fmri.zip')
zf.extractall()

#GM data gathering
import os

count_val = 0.0
healthy_img_count = 0
ms_img_count = 0
threshold = 65 #number to determine how "gray" the gray matter is; this number was determined by using another control dataset 
               #to find the threshold that gives us around 40% gray matter per brain
fmri_data = {}

#parsing healthy fmri data
for filename in os.listdir('/content/healthyfmri'):
  path = '/content/healthyfmri/' + str(filename) #setting the path for the image
  img = cv2.imread(path)
  if img is None:
    x = 4 #random arbitrary function to fill the if statement
  else:
    healthy_img_count += 1
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #gray-scaling the image to value each pixel to one number
    x,y = gray.shape
    for i in range(x):
      for j in range(y):
        if gray[i][j] >= threshold:
          count_val += 1
    key = count_val/(x*y)
    fmri_data[key] = 0.0 #0.0 indicates that this is a patient without MS 
    count_val = 0.0 #reset the count value

#parsing ms fmri data
for filename in os.listdir('/content/msfmri'):
  path = '/content/msfmri/' + str(filename) #setting the path for the image
  img = cv2.imread(path)
  if img is None:
    x = 4 #random arbitrary function to fill the if statement
  else:
    ms_img_count += 1
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #gray-scaling the image to value each pixel to one number
    x,y = gray.shape
    for i in range(x):
      for j in range(y):
        if gray[i][j] >= threshold:
          count_val += 1
    key = count_val/(x*y)
    fmri_data[key] = 1.0 #1.0 indicates that this is a patient with MS 
    count_val = 0.0 #reset the count value
  
print(fmri_data)

#data: {0.39414414414414417: 0.0, 0.33446890286512926: 0.0, 0.37264804911863736: 0.0, 0.35477719791248497: 0.0, 
#       0.35620220900594735: 0.0, 0.3146289146289146: 0.0, 0.2454351145038168: 0.0, 0.395578231292517: 0.0, 
#       0.3563869992441421: 0.0, 0.3268349970640047: 0.0, 0.39263740771123873: 0.0, 0.23225764134855045: 0.0, 
#       0.38958333333333334: 0.0, 0.35172546380851677: 0.0, 0.3616258741258741: 0.0, 0.3522216225939917: 0.0, 
#       0.308964986533282: 0.0, 0.33549010140028973: 0.0, 0.29026904262753317: 0.0, 0.33295454545454545: 0.0, 
#       0.3401442307692308: 0.0, 0.352891156462585: 0.0, 0.3076879910213244: 1.0, 0.27203369140625: 1.0, 
#       0.35653471915081825: 1.0, 0.27634108527131784: 1.0}

import zipfile
import io
zf = zipfile.ZipFile('healthy_dti.zip')
zf.extractall()
#zf.printdir()

zf = zipfile.ZipFile('ms_dti.zip')
zf.extractall()

#FA data gathering

count_val = 0.0
overall = 0
healthy_dti_count = 0
ms_dti_count = 0
dti_data = {}

#parsing healthy dti data
for filename in os.listdir('/content/healthydti'):
  path = '/content/healthydti/' + str(filename) #setting the path for the image
  img = cv2.imread(path)
  if img is None:
    x = 4 #random arbitrary function to fill the if statement
  else:
    healthy_dti_count += 1
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #gray-scaling the image to value each pixel to one number
    x,y = gray.shape
    for i in range(x):
      for j in range(y):
        if gray[i][j] > 25: #excluding the black space around the fmri scans to account for uneven image boundries
          count_val += gray[i][j]
          overall += 1
    dti_data[count_val/(overall*255)] = 0.0 #0.0 indicates a healthy patient without MS; overall is multiplied by 255 (the max value) to scale the number to a value from 0 to 1
    count_val = 0.0
    overall = 0

#parsing ms dti data
for filename in os.listdir('/content/msdti'):
  path = '/content/msdti/' + str(filename) #setting the path for the image
  img = cv2.imread(path)
  if img is None:
    x = 4 #random arbitrary function to fill the if statement
  else:
    ms_dti_count += 1
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #gray-scaling the image to value each pixel to one number
    x,y = gray.shape
    for i in range(x):
      for j in range(y):
        if gray[i][j] > 25: #excluding the black space around the fmri scans to account for uneven image boundries
          count_val += gray[i][j]
          overall += 1
    dti_data[count_val/(overall*255)] = 1.0 #1.0 indicates a healthy patient with MS
    count_val = 0.0
    overall = 0

print(dti_data)

#data: {0.3445595302644811: 0.0, 0.3530403875758399: 0.0, 0.47463641023922387: 0.0, 0.4100262437024692: 0.0, 
#       0.3477709410123882: 0.0, 0.37234637395628106: 0.0, 0.34410153741022265: 0.0, 0.29862122125683327: 0.0, 
#       0.3849253529363434: 0.0, 0.3485019425285389: 0.0, 0.3662764029149558: 0.0, 0.3438860701244838: 0.0, 
#       0.3895600813101676: 1.0, 0.5041013808830899: 1.0, 0.46990192369975353: 1.0, 0.5250594469820513: 1.0, 
#       0.4914573246277449: 1.0, 0.3725568123917253: 1.0, 0.44882071459282563: 1.0, 0.48042370628727865: 1.0, 
#       0.5263797826823037: 1.0, 0.5791412297217626: 1.0, 0.4107991662610302: 1.0, 0.3832412432969863: 1.0, 
#       0.44056274652199295: 1.0, 0.41214248742159193: 1.0, 0.49875721963529623: 1.0, 0.4191128469539237: 1.0, 
#       0.562317248953257: 1.0, 0.4029357570877785: 1.0, 0.4011563672400368: 1.0, 0.5059023035251147: 1.0, 
#       0.5036494399494618: 1.0, 0.4471205840142538: 1.0, 0.42837424013894604: 1.0, 0.5052946415389085: 1.0, 
#       0.4652082542911497: 1.0, 0.40202703812605745: 1.0, 0.4718553020259112: 1.0, 0.5290425435000455: 1.0, 
#       0.39816997149910294: 1.0, 0.4135069173883: 1.0, 0.4508300260652023: 1.0, 0.4682380890424491: 1.0, 
#       0.5214581607290804: 1.0}

labels = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) #12 control, 20 MS patients
trainingData = np.matrix([[0.39414414414414417, 0.3445595302644811], [0.33446890286512926, 0.3530403875758399], [0.37264804911863736, 0.47463641023922387], [0.35477719791248497, 0.4100262437024692],
                         [0.35620220900594735, 0.3477709410123882], [0.3146289146289146, 0.37234637395628106], [0.2454351145038168, 0.34410153741022265], [0.395578231292517, 0.29862122125683327],
                         [0.3563869992441421, 0.3849253529363434], [0.3268349970640047, 0.3485019425285389], [0.39263740771123873, 0.3662764029149558], [0.23225764134855045, 0.3438860701244838],
                         [0.3076879910213244, 0.3895600813101676], [0.27203369140625, 0.5041013808830899], [0.35653471915081825, 0.46990192369975353], [0.27634108527131784, 0.5250594469820513],
                         [0.3239480250793201, 0.4914573246277449], [0.29319237029179, 0.3725568123917253], [0.34290235712939755, 0.44882071459282563], [0.29219834791259872, 0.48042370628727865],
                         [0.3130923987261823, 0.5263797826823037], [0.33193581790928, 0.5791412297217626], [0.28921283728619943, 0.4107991662610302], [0.29219834791259872, 0.3832412432969863],
                         [0.3076879910213244, 0.44056274652199295], [0.27203369140625, 0.41214248742159193], [0.35653471915081825, 0.49875721963529623], [0.27634108527131784, 0.4191128469539237],
                         [0.33193581790928, 0.562317248953257], [0.3239480250793201, 0.4029357570877785], [0.29319237029179, 0.4011563672400368], [0.34290235712939755, 0.5059023035251147]], dtype=np.float32)
trainingData *= 750 #scaling points to make it easier to see on plot
#potential error: the scans associated with each other are not from the same person; in addition, MS fmri scan data was repeated in order to accomdate for low data

def plot_decision_function(est):
    xx, yy = np.meshgrid(np.linspace(-3, 3, 500),
                         np.linspace(-3, 3, 500))
    # We evaluate the decision function on the grid.
    Z = est.decision_function(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    cmap = plt.cm.Blues
    # We display the decision function on the grid.
    plt.figure(figsize=(5,5));
    plt.imshow(Z,
                extent=(xx.min(), xx.max(), yy.min(), yy.max()),
                aspect='auto', origin='lower', cmap=cmap);
    # We display the boundary where Z = 0
    plt.contour(xx, yy, Z, levels=[0], linewidths=2,
                colors='k');
    # All point colors c fall in the interval .5<=c<=1.0 on the blue colormap. We color the true points darker blue.
    plt.scatter(X[:, 0], X[:, 1], s=30, c=.5+.5*y, lw=1,
                cmap=cmap, vmin=0, vmax=1);
    plt.axhline(0, color='k', ls='--');
    plt.axvline(0, color='k', ls='--');
    plt.xticks(());
    plt.yticks(());
    plt.axis([-3, 3, -3, 3]);

import cv2 as cv
import sklearn
from sklearn.model_selection import train_test_split
from sklearn import svm

X_train, X_test, y_train, y_test = train_test_split(trainingData, labels, test_size = 0.2, random_state=0)


clf = svm.SVC(kernel='linear')
clf.fit(X_train, y_train)

clf_predictions = clf.predict(X_test)
print("Accuracy: {}%".format(clf.score(X_test, y_test) * 100 ))

def make_meshgrid(x, y, h=.02):
    x_min, x_max = x.min() - 1, x.max() + 1
    y_min, y_max = y.min() - 1, y.max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))
    return xx, yy

def plot_contours(ax, clf, xx, yy, **params):
    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    out = ax.contourf(xx, yy, Z, **params)
    return out

fig, ax = plt.subplots()
# title for the plots
title = ('Decision surface of linear SVM')
# Set-up grid for plotting.
X0, X1 = X_train[:, 0], X_train[:, 1]
xx, yy = make_meshgrid(X0, X1)

plot_contours(ax, clf, xx, yy, cmap=plt.cm.coolwarm, alpha=0.8)
#ax.scatter(X0, X1, c=y, cmap=plt.cm.coolwarm, s=20, edgecolors='k')
ax.set_ylabel('FA Values')
ax.set_xlabel('GM Values')
ax.set_xticks(())
ax.set_yticks(())
ax.set_title(title)

count = 0
for i in trainingData:
  count += 1
  if (count < 13):
    circle = plt.Circle((i[0,0], i[0,1]), 0.4, color = "black")
  else:
    circle = plt.Circle((i[0,0], i[0,1]), 0.4, color = "white")
  ax.add_patch(circle)

plt.show()

'''
# Train the SVM
svm = cv.ml.SVM_create()
svm.setType(cv.ml.SVM_C_SVC)
svm.setKernel(cv.ml.SVM_LINEAR)
#svm.setTermCriteria((cv.TERM_CRITERIA_MAX_ITER, 100, 1e-6))
svm.train(trainingData, cv.ml.ROW_SAMPLE, labels)

# Data for visual representation
width = 512 #x-axis represents fmri values
height = 512 #y-axis represents dti values
image = np.zeros((height, width, 3), dtype=np.uint8)

# Show the decision regions given by the SVM
green = (152,251,152)
blue = (175,238,238)
for i in range(image.shape[0]):
    for j in range(image.shape[1]):
        sampleMat = np.matrix([[j,i]], dtype=np.float32)
        response = svm.predict(sampleMat)[1]
        if response == 1:
            image[i,j] = green
        elif response == 0:
            image[i,j] = blue

# Show the training data
thickness = -1
count = 0
for i in trainingData:
  count += 1
  if (count < 13):
    cv.circle(image, (i[0,0],  i[0,1]), 5, (0, 0, 0), thickness) #control patients in black
  else:
    cv.circle(image, (i[0,0],  i[0,1]), 5, (255, 255, 255), thickness) #MS patients in white

# Show support vectors
thickness = 2
sv = svm.getUncompressedSupportVectors()
for i in range(sv.shape[0]):
    cv.circle(image, (int(sv[i,0]), int(sv[i,1])), 6, (255, 0, 0), thickness)

plt.imshow(image), plt.show()
'''